# ERC777, A New Advanced Token Standard For Ethereum Tokens

ERC777 is a new advanced token standard for Ethereum tokens. It is the result of the work described in this paper and made in collaboration with Jordi Baylina from the White Hat Group and Giveth.

The standard describes three central mechanisms: sending tokens, minting tokens and burning tokens. Those mechanisms are performed by a specific role---an operator---which is also defined in the standard. These mechanisms take advantage of hooks---specific functions which are called to notify and/or control the debit or credit of tokens. Lastly, ERC777 includes extra constraints for backwards compatibility with ERC20.

Creating a new standard requires careful consideration. Many aspects had to be considered such as security, usability, compatibility with the existing ecosystem and backward compatibility with existing ERC20 infrastructures. All things considered, ERC777 brings many enhancements including data associated with transactions, operators, hooks and backward-compatibility with ERC20 which address the previously mentioned considerations.

## Operators

An operator is a specific role which must be defined first, in order to properly understand the three mechanisms described below. In one sentence:

> An operator is an address which is allowed to send and burn tokens on behalf of another address \citep{erc777}.

On top, of this core definition, constraints are defined and applied for all operators. First, every address is always an operator for itself. This right is not revocable. Second, any address--regular accounts or contract---is allowed to authorize and later revoke other addresses as their operators. Therefore some accounts may have their token funds managed by another party. Ideally, operators are intended to be contracts whose code may be audited. As a result, users can authorize a contract as their operator without the fear of the operator withdrawing all their tokens. Evidently this implies users have previously verified the code of the operator and they have convinced themselves the code operator does not include vulnerabilities and is not able to withdraw all the funds. Examples of such operator contracts include payment or cheque processors, \glspl{dex}, subscription managers and automatic payment systems.

There are also interesting scenarios which leverage hooks to authorize regular accounts as operators whilst only letting them spend tokens according to specific rules.

### Default Operators

All addresses are automatically and irrevocably operators for themselves---and may explicitly authorize any other address(es) as operator(s). Additionally, any token contract may define a set of operators at creation/deployment time which are implicitly authorized for all token holders. This feature allows token designers to offer additional features specific to their token---with a modular design---to let their users move their funds more seamlessly/in a more integrated fashion.  It's worth noting that a token contract which enables default operators would implicitly require that these operators are included in any review of the token contract.  Taking inspiration from the previous examples for operators. If a token is used a form of payment for subscription. The company behind the service may be interested to not only create the token but an operator to directly and regularly levy the subscription fee. Since the use---and therefore the value---of the token are based on this subscription service, it is logical to authorize the subscription operator by default. Obviously, default operators can be revoked by the token holder and a token contract must not be able to change the list of default operators after the contract is created.

### Authorizing And Revoking Operators

Authorizing operators is the process where an address authorizes another address as its operator. An address may authorize many operators at the same time. However only the token holder can authorize operators for itself.

This last constraint is extremely important for contract as it implies that one must correctly implement some logic to let the contract authorize the operators it needs. Essentially only the contract itself is allowed to set its operators. For a contract which does not expose a function to perform arbitrary calls, it must implement one or more call to authorize operators in the constructor or some other function. Otherwise, the contract will never be able to authorize any operator.

ERC777 defines a specific function to authorize an operator: `authorizeOperator`. This function takes the address of the operator as parameter and authorizes it for the address which initialized the call (`msg.sender`). The standard requires the implementation of this function but it does not however constrain the authorization mechanism to this function. In other words, the token may define other mechanisms to authorize operators as long as those mechanisms are compliant. For example they must emit the `AuthorizedOperator` event with the correct data.

Similarly, ERC777 defines a specific function to revoke an operator: `revokeOperator`. This function takes the address of the operator as parameter and revokes it as an operator for the address which initialized the call (`msg.sender`). The standard requires the implementation of this function but it does not however constrain the revocation mechanism to this function. Essentially, the token may define other mechanisms to revoke operators as long as those mechanisms are compliant. For example they must emit the `RevokedOperator` event with the correct data.

## Hooks

A hook is a specific function which is called to notify the debit or credit of tokens. Specifically, ERC777 defines two hook functions `tokensToSend` to notify of the debit of tokens and `tokensReceived` to notify of the credit of tokens. Furthermore, if the recipient is a contract, the `tokensReceived` hook must be called---to notify of the credit and give an opportunity for the receiving contract to react and to prevent locking the tokens.

### Preventing Locked Tokens

Locked tokens, as explained in section \ref{locked-tokens}, refers to tokens held by a contract which is not aware of the fact and is unable to spend said tokens. The `tokensReceived` hook gives the chance for contracts to be notified of any credit and react to it. This hook is extremely important from a safety standpoint when the recipient is a contract, therefore ERC777 stipulates that it is mandatory for contracts to register a `tokensReceived` hook in order to receive tokens. This is the only scenario where a hook is required. Sending tokens to a regular account will never result in locked token, providing the person behind the account has the private key. Some people explicitly look tokens by sending them to addresses composed of specific patterns for which it is unlikely anyone has the private key. Example of such accounts include `0x1111111111111111111111111111111111111111` which holds 39 different tokens or `0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead` which holds 21 different tokens. One exception is the \gls{0x} where people have unintentionally locked tokens. Indeed, Solidity automatically pads values with zeroes. As a result, calling a function such as ERC20's `transfer` with a `to` parameter uninitialized will result in a transfer of tokens to the \gls{0x}. This is part of the reason which led to the decision to forbid sending tokens to the \gls{0x} address in ERC777.

### Location Of The Hooks

One essential aspect is where those hooks are located. One approach is to have those hook functions located at the recipient, but this has two significant drawbacks. First the recipient must then be a contract to implement the hooks---hence regular accounts could not use hooks. Secondly, existing contracts do not implements the hooks and could not receive ERC777 tokens.

The approach used in ERC777 is to use a registry to lookup the address of the contract implementing the hook for a given recipient. This approach has many advantages over the previously mentioned one. Primarily, all addresses, even regular accounts, can use the registry to register a contract implementing the hook on their behalf. Second, this means that existing contracts can also register hooks via a proxy contract which implements the hook on their behalf. Essentially this means that an account or an already deployed contract can simply deploy a new contract to implement these hooks on their behalf.

ERC777 relies upon this registry, but the registry itself is not part of the standard. Instead, the registry is specified in a separate standard, ERC820: A Pseudo-introspection Registry Contract \citep{erc820}, outlined in chapter \ref{erc820-pseudo-introspection-registry-contract}. ERC777 then simply relies upon ERC820. The advantage of dissociating the token standard from the registry is that first it can be used by other standards and secondly it offers a good separation of concerns. Any developer wishing to work with ERC777---whether it is to implement a token or any kind of \gls{dapp}---will need to thoroughly understand ERC777 in order to deploy code which is compliant. In comparison, the ERC820 registry should already be deployed and the developer only need to understand how to properly interact with it.

## Sending Tokens

Unlike ERC20 which defines a couple functions to send tokens, ERC777 focuses on specifying the process which must be followed when sending tokens. The standard then enforces the presence of two functions---`send` and `operatorSend`---which apply the send process. Other non-standard functions may be added when creating an ERC777 token contract, as long as those functions follow the specification of the send process.

The send process works as follow. First only an authorized operator can send the tokens of a token holder. This includes the token holder itself, a non-revoked default operator (if any) or some other explicitly authorized operator. Second, a few (obvious) rules must be enforced, such as the recipient cannot be the \gls{0x}. The amount to send must not be greater than the balance of the token holder, the amount must be a multiple of the granularity (see \ref{decimals-and-granularity}) and the appropriate balances updated accordingly, a `Sent` event must be emitted and more importantly, the `tokensToSend` and `tokensReceived` hooks must be fired before and after updating the balances, respectively.

Another aspect of sending tokens is the `data` and `operatorData` parameters, which is an undeniable improvement over ERC20 where only the recipient and amounts of tokens can be specified as part of a transfer. The `data` parameter is intended to be similar to the `data` parameter of a regular Ethereum transaction and the standard intentionally does not enforce a specific format for this data only that the recipient defines what data it expects. We expect people will propose new standard related to the format of the `data` parameter which define the format required for a specific use case. ERC1111\citep{erc1111} is an effort in this direction.

## Minting Tokens

## Burning Token

## View Functions

The view functions in ERC777 have been taken from ERC20. Since those functions do not modify the state, they can be used interchangeably for both standards without creating conflicts. The only constraint is that the information returned by these functions must represent the same entity.

Specifically the `name`, `symbol`, `totalSupply` and `balanceOf` functions are kept. The differences with ERC20 is that the cosmetic `name` and `symbol` function are now mandatory. In addition there are more strict constraints on the value returned by calls to the `totalSupply` and `balanceOf` functions.

## Decimals

The ERC20 `decimal` function is notoriously absent from the view functions listed above. As previously explained, a variable `decimals` value is problematic. For this reason the `decimals` has been set at a fixed value of $18$. This renders the `decimals` function pointless. The standard only enforces the implementation of the `decimals` function when implementing a ERC20 backward-compatible token. In this case the `decimals` function must both be implemented and return $18$. The choice has been made to make the `decimal` function mandatory in this case, even though ERC20 considers the function optional. The rational behind this decision comes from the lack of an explicit value defined in the ERC20 standard when the `decimals` function is not defined. Furthermore, requiring people to check wether a token is both ERC20 and ERC777 compatible---and then deduct from the ERC777 standard that the number of decimals is $18$---is both unreliable and terrible user experience. Besides, this would add an opaque constraint when implementing both standards.

## Compatibility

One key aspect for the ERC777 standard is to maintain compatibility with the older ERC20 standard. The Ethereum ecosystem is hard and slow to update. This translates to many wallets, \glspl{dex} and other \glspl{dapp} which today support ERC20 but will not support ERC777 for years to come if not ever. Hence ERC777 tokens will not be supported on existing platforms immediately, which is a problem for people wishing to sell and trade their ERC777 token. Having a token able to behave at first like an ERC20 token on those platforms alongside with the newer ERC777 behavior is a major social and economic advantage.

### Notifying The Recipient

One of the main feature of ERC777 is to do away with the `approve` and `transferFrom` mechanism and instead provide a single mechanism to send tokens to both regular accounts and contracts. For a contract, it is then mandatory for it to be notified on-chain when it receives tokens. This is done with the use of "hooks" or specific functions which are called

### ERC20 Backward Compatibility

Many proposition try to fix ERC20 and amend the specifications to modify the behavior of functions such as `transfer`. A new standard on the other hand should not modify the behavior of existing functions defined in another standard, but rather define different functions which implement the new behaviors.

Additionally, having functions with disparate names allows people to differentiate with which standard they are interacting with. As an example, with ERC20, to send tokens to a contract, a user should typically use `approve`---instead of calling `transfer` directly---and let the recipient call `transferFrom`. On the other hand, ERC777 defines a `send` function (described later) which is safe to use to send tokens to a contract. Let us assume this `send` function was named `transfer` instead. The user must know figure out beforehand if the tokens he wishes to send implement ERC20 or ERC777. This burden also applies to contract forwarding contracts. Overall having the same name would create confusion and result in many mistakes where people end up loosing their tokens.




Explain ERC777 in thorough details:

 - specifications
 - ERC820
 - `TokensSender` and `TokensRecipient`
 - Operators
 - ERC20 compatibility
 - Collaboration with Jordi Baylina
 - Public Reception
