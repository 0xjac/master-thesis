# ERC777, A New Advanced Token Standard For Ethereum Tokens

ERC777 is a new advanced token standard for Ethereum tokens. It is the result of the work described in this thesis and made in collaboration with Jordi Baylina from the White Hat Group and Giveth. The official version of the ERC777 standard is available at \url{https://eips.ethereum.org/EIPS/eip-777}\footnote{Source for the ERC777 standard: \url{https://github.com/ethereum/EIPs/blob/master/EIPS/eip-777.md}}.

The standard describes three central mechanisms: sending tokens, minting tokens and burning tokens. Those mechanisms are performed by a specific role---an operator---which is also defined in the standard. These mechanisms take advantage of hooks---specific functions which are called to notify and control the debit or credit of tokens. Lastly, ERC777 includes extra constraints for backwards compatibility with ERC20.

Creating a new standard requires careful consideration. Many aspects had to be considered such as security, usability, compatibility with the existing ecosystem and backward compatibility with existing ERC20 infrastructures. All things considered, ERC777 brings many enhancements including data associated with transactions, operators, hooks and backwards-compatibility with ERC20 which address the previously mentioned considerations in section \ref{strengths-and-weaknesses-of-erc20}.

## Operators

An operator is a specific role which must be defined first, in order to correctly understand the three mechanisms described below. In one sentence:

> An operator is an address which is allowed to send and burn tokens on behalf of another address \citep{erc777}.

On top of this core definition, constraints are defined and applied to all operators. First, every address is always an operator for itself. This right is not revocable. Second, any address--regular account or contract---is allowed to authorise and later revoke other addresses as their operators. Therefore some accounts may have their token funds managed by another party. Ideally, operators are intended to be contracts whose code may be audited. As a result, users can authorise a contract as their operator without the fear of the operator withdrawing all their tokens. Evidently, this implies users have previously verified the code of the operator, and they have convinced themselves that the operator code does not include vulnerabilities and is not able to withdraw all the funds. Examples of such operator contracts include payment or cheque processors, \glspl{dex}, subscription managers and automatic payment systems.

There are also exciting scenarios which leverage hooks to authorise regular accounts as operators whilst only letting them spend tokens according to specific rules.

### Default Operators

All addresses are automatically and irrevocably operators for themselves---and may explicitly authorise any other address(es) as operator(s). Additionally, any token contract may define a set of operators at creation time which are implicitly authorised for all token holders. This feature allows token designers to offer additional features specific to their token---with a modular design---to let their users move their funds more seamlessly, in a more integrated fashion. It is worth noting that a token contract which enables default operators would implicitly require that these operators are included in any review or audit of the token contract. Taking inspiration from the examples of operators mentioned at the end of section \ref{operators}, if a token is used as a form of payment for subscription, the company behind the service may be interested in not only creating the token but creating an operator as well to directly and regularly levy the subscription fee. Since the use---and therefore the value---of the token is based on this subscription service, it is logical to authorise the subscription operator by default. Default operators can be revoked by the token holder, and a token contract must not be able to change the list of default operators after the contract is created.

### Authorising And Revoking Operators

Authorising operators is the process where an address authorises another address as its operator. An address may authorise many operators at the same time. However, only the token holder can authorise operators for itself.

This last constraint is significant for any contract wishing to hold tokens and use (other) operators as it implies that one must correctly implement some logic to let the contract authorise the operators it needs. Essentially only the contract itself is allowed to set its operators. For a contract which does not expose a function to perform arbitrary calls, it must implement one or more call to authorise operators in the constructor or some other function. Otherwise, the contract will never be able to authorise any operator.

ERC777 defines a specific function to authorise an operator: `authoriseOperator`. This function takes the address of the operator as a parameter and authorises it for the address which initialised the call (`msg.sender`). The standard requires the implementation of this function, but it does not, however, constrain the authorisation mechanism to this function. In other words, the token contract may define other mechanisms to authorise operators as long as those mechanisms are compliant with the ERC777 standard. For example, they must emit the `AuthorizedOperator` event with the correct data.

Similarly, ERC777 defines a specific function to revoke an operator: `revokeOperator`. This function takes the address of the operator as a parameter and revokes it as an operator for the address which initialised the call (`msg.sender`). The standard requires the implementation of this function, but it does not, however, constrain the revocation mechanism to this function. Essentially, the token may define other mechanisms to revoke operators as long as those mechanisms are compliant. For example, they must emit the `RevokedOperator` event with the correct data.

## Hooks

A hook is a specific function which is called to notify and let the accounts control the debit or credit of tokens. Specifically, ERC777 defines two hook functions `tokensToSend` to notify the debit of tokens and `tokensReceived` to notify of the credit of tokens. Furthermore, if the recipient is a contract, the `tokensReceived` hook must be called---to notify of the credit and give an opportunity for the receiving contract to react and to prevent locking the tokens.

In any case, both the account from which the tokens are debited and the account to which the tokens are credited can implement hooks which revert the transaction if a condition is met. Thus providing greater control to accounts over which token they wish to send or receive.

### Preventing Locked Tokens

Locked tokens, as explained in section \ref{locked-tokens}, refers to tokens held by a contract which is not aware of the fact and is unable to spend said tokens as these contracts do not have the functionality to call the token contract and have no upgrade or migration system in place---often as a design choice. The `tokensReceived` hook gives a chance for contracts to be notified of any credit and react to it. This hook is critical from a safety standpoint when the recipient is a contract. Therefore ERC777 stipulates that it is mandatory for contracts to register a `tokensReceived` hook in order to receive tokens. This is the only scenario where a hook is required. While making the hook mandatory for contracts ensures they can react when they receive contracts, it does not guarantee that the token will never be locked. Having a hook which does nothing or which is incorrectly implemented can still result in locked tokens. The hook provides a chance for the contract developers to handle the reception of tokens which was not possible with ERC20 and reduce a large number of human errors where users mistakenly transferred tokens to a contract using ERC20's `transfer` function.

Sending tokens to a regular account will never result in locked tokens, providing the person behind the account has the private key. Some people explicitly lock tokens by sending them to addresses composed of specific patterns for which it is unlikely anyone has the private key. Example of such accounts includes `0x1111111111111111111111111111111111111111` which holds 39 different tokens or `0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead` which holds 21 different tokens. One exception is the \gls{0x} where people have unintentionally locked tokens. Indeed, Solidity automatically pads values with zeroes. As a result, calling a function such as ERC20's `transfer` with a `to` parameter uninitialised will result in a transfer of tokens to the \gls{0x}. This is part of the reason which led to the decision to forbid sending tokens to the \gls{0x} in ERC777. This constraint is enforced by explicitly checking the recipient address in the token contract and reverting the transaction if it the recipient is the \gls{0x}.

### Location Of The Hooks

One essential aspect is where those hooks are located. One approach is to have those hook functions located at the recipient, but this has two significant drawbacks. First, the recipient must then be a contract to implement the hooks---hence regular accounts could not use hooks. Secondly, existing contracts do not implement the hooks and could not receive ERC777 tokens.

The approach used in ERC777 is to use a registry to lookup the address of the contract implementing the hook for a given recipient. This approach has many advantages over the previously mentioned one. Primarily, all addresses, even regular accounts, can use the registry to register a contract implementing the hook on their behalf. Second, this means that existing contracts can also register hooks via a proxy contract which implements the hook on their behalf. Essentially this means that an account or an already deployed contract can just deploy a new contract to implement these hooks on their behalf. This is vital for \glspl{multisig} which can hold large amounts of ether and tokens and may not want to move all the funds to a new wallet.

ERC777 relies upon this registry which had to be created since there was no suitable registry existing as explained in chapter \ref{erc820-pseudo-introspection-registry-contract}. The registry was created to be used by ERC777, but it is not itself part of the ERC777 standard. Instead, the registry is specified in a separate standard, ERC820: A Pseudo-introspection Registry Contract \citep{erc820}, outlined in chapter \ref{erc820-pseudo-introspection-registry-contract}. ERC777 then relies upon ERC820. The advantage of dissociating the token standard from the registry is that first it can be used by other standards and secondly it offers a good separation of concerns. Any developer wishing to work with ERC777---whether it is to implement a token or any kind of \gls{dapp}---will need to thoroughly understand ERC777 in order to deploy code which is compliant. In comparison, the ERC820 registry should already be deployed, and the developer only needs to understand how to interact with it properly.

## Sending Tokens

Unlike ERC20 which defines a couple of functions to send tokens, ERC777 focuses on specifying the process which must be followed when sending tokens. The standard then enforces the presence of two functions---`send` and `operatorSend`---which apply the send process. Other non-standard functions may be added when creating an ERC777 token contract, as long as those functions follow the specification of the send process.

\input{fig/sendNoHooks.tex}

The send process works as follows. First only an authorised operator can send the tokens of a token holder. This includes the token holders themselves, a non-revoked default operator (if any) or some other explicitly authorised operator. Second, a few (obvious) rules must be enforced, such as the recipient cannot be the \gls{0x}. The amount to send must not be greater than the balance of the token holder, the amount must be a multiple of the granularity (see \ref{decimals-and-granularity}) and the appropriate balances must be updated accordingly, a `Sent` event must be emitted and more importantly, the `tokensToSend` and `tokensReceived` hooks must be fired before and after updating the balances, respectively.

\pagebreak

The most simple use case is for a regular account---let's call her Alice---to send tokens to another regular account---let's call him Bob---and neither account has a registered hook. In this scenario, Alice can call the standard `send` function with Bob's address and the amount of tokens. The token contract will check for the existence of a `tokensToSend` hook implementation for Alice, find none and move on to update the balances. Afterwards, it will check for the existence of a `tokensReceived` hook for Bob. Upon finding no `tokensReceived` hook for Bob, the token contract will verify that Bob is a regular account. This scenario is illustrated in figure \ref{fig:sendNoHooks}.

\input{fig/sendToContract.tex}

If the recipient Bob was a contract instead of a regular account, then this recipient contract---let's call it Carlos---must provide a `tokensReceived` hook which will be called. The simplest case is for Carlos to implement the hook itself. As a result, Carlos itself will be called as depicted in figure \ref{fig:sendToContract}.

\pagebreak
\input{fig/sendToContractNoHook.tex}

If Carlos fails to provide a `tokensReceived` hook, the token contract will check that Carlos is a regular account. Since it is not the check will fail, and the `send` will be reverted, as represented in figure \ref{fig:sendToContractNoHook}. Carlos is also allowed to provide a different contract to implement the `tokensReceived` hook on its behalf.

\input{fig/sendProxyTokensRecipient.tex}

In this case---depicted in figure \ref{fig:sendProxyTokensRecipient}---the hook is called, but the actual recipient is not. It is up to the hook to be correctly implemented and to take the proper actions to ensure that Carlos can use the tokens in the future. This logic is tightly-coupled with the goal and implementation of Carlos, and it is up to its developers to implement everything correctly.

So far the scenarios focused on the `tokensReceived` hook which is the only required hook when the recipient is a contract. The other hook, `tokensToSend`, is entirely optional and a transaction should not be reverted because of its absence. Both hooks can be used together, either directly on the token holder and the recipient or via proxy contracts. The figures \ref{fig:sendProxyTokensSenderDirectTokensRecipient} and \ref{fig:sendProxyHooks} illustrate the use of a `tokensToSend` hook in combination with a `tokensReceived` which is directly set on the recipient and on a proxy contract respectively.

\input{fig/sendProxyTokensSenderDirectTokensRecipient.tex}
\pagebreak
\input{fig/sendProxyHooks.tex}

## Minting Tokens

Minting is the technical term referring to the creation of new tokens---it originates from the minting of metal coins. The creation of tokens in Ethereum is particular to the asset represented by the token and involves various mechanisms accordingly. Some tokens have a fixed amount of tokens minted at creation time---often referred to as pre-mining---where the tokens are given to the user(s) controlling the contract. Other tokens have an issuance model which mint tokens according to signed messages provided by a trusted third party.

The listings \ref{lst:alismint} and \ref{lst:statusmint1}, \ref{lst:statusmint2}, \ref{lst:statusmint3} illustrate two widely different minting process. The Alis token (figure \ref{lst:alismint}) uses a minting process inspired by OpenZepplin's Crowdsale logic \footnote{\href{https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/crowdsale/Crowdsale.sol\#L83}{github.com/OpenZeppelin/openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol\#L83}}. This is a very simple logic where tokens are issued to the pro-rata of ether sent to the contract. After passing some checks (on lines 2 to 5), line 15 computes the amount of tokens to mint based on the amount of ether sent (in wei). On line 18 the contract updates the amount of ether received. Finally on line 20, the tokens are minted for the beneficiary.
\begin{minipage}{\linewidth}\centering
\lstinputlisting[caption={Minting process for the Alis Token Crowdsale},label=lst:alismint,language=Solidity]{lst/alismint.sol}
\end{minipage}

The status token uses a much more complex minting process, displayed in listings \ref{lst:statusmint1}, \ref{lst:statusmint2} and \ref{lst:statusmint3}. The user must call the `proxyPayment` function (listing \ref{lst:statusmint1}, line 1) which detects if the buyer has a guaranteed amount of tokens to purchase. If not the purchase continues with the `buyNormal` function (listing \ref{lst:statusmint1}, line 6 and listing \ref{lst:statusmint2}, line 1). Next, the purchase process has an anti-spam policy which gets updated on line 15 (listing \ref{lst:statusmint2}), and the maximum amount of ether a person can invest is computed based on a dynamic ceiling (listing \ref{lst:statusmint1}, line 18). Finally the purchase is processed (listing \ref{lst:statusmint2}, line 28 and listing \ref{lst:statusmint3}, line 2) and the new tokens are minted for the buyer on line 8 (listing \ref{lst:statusmint3}).

\begin{minipage}{\linewidth}\centering
\lstinputlisting[firstline=1,lastline=10,caption={Minting process for the Status token (\texttt{proxyPayment} function).},label=lst:statusmint1,language=Solidity]{lst/statusmint.sol}
\end{minipage}

\begin{minipage}{\linewidth}\centering
\lstinputlisting[firstline=11,lastline=40,caption={Minting process for the Status token(\texttt{buyNormal} function).},label=lst:statusmint2,language=Solidity]{lst/statusmint.sol}
\end{minipage}

\begin{minipage}{\linewidth}\centering
\lstinputlisting[firstline=40,lastline=63,caption={Minting process for the Status token (\texttt{doBuy} function).},label=lst:statusmint3,language=Solidity]{lst/statusmint.sol}
\end{minipage}

On the one hand, because of these varying issuance models, it is hard to provide a standardised process which creates tokens. Therefore, this is intentionally left out of ERC777. On the other hand, ERC777 does define a set of rules which must be respected when minting new tokens. These rules include:

1. The total supply must be updated to reflect the mint.
2. The tokens must be minted for an account whose balance must be increased
3. A `Minted` event must be fired.
4. The `tokensReceived` hook must be called if present.
5. If the recipient is a contract which does not have a `tokensReceived` hook, the minting process must revert.

The rationale for enforcing minting rules originates from reading various ERC20 token contracts and seeing the differences in implementation for each token. From the recipients' point of view, minting and sending tokens is similar. Therefore it is critical to have a well-defined and predictable process when an account receives tokens whether they come from a send or mint.

The main difference with respect to send is, with minting, the `from` address is the \gls{0x} which indicates the tokens are newly created. The notion of an operator is also slightly different for minting. As mentioned in chapter \ref{operators}, an operator is an address which can spend the tokens of some account (either through sending or burning). This notion does not apply to minting as no one previously owns the minted tokens. ERC777 does not enforce any constraint on which address can mint tokens. It is up to each token to define conditions in order to restrain the minting process such that it matches the desired issuance model. For example, the minting can be entirely restricted, only allow some addresses to mint, or only allow minting in certain quantities, at certain times or if some other condition is met such as providing a signed message. These various issuances model are the reason why there is no explicit function for minting as part of the standard.

## Burning Tokens

Burning tokens, similarly to minting can be specific to which asset a token represents. Some token contracts may wish never to allow burning of tokens, others may only allow some addresses to burn token, and some may allow anyone to burn tokens if specific conditions are met. Lastly, token contracts may want or need to take specific actions when tokens are burned, e.g., a token may represent a redeemable asset where the token is burned in order to redeem the asset.

Because burning involves a loss of tokens for users, similar to a send, it is essential to define a well-known and predictable behaviour as well. Furthermore, standard burning functions---similar to send---are defined to allow wallets and \glspl{dapp} to let their users burn their token easily. Moreover, if a token contract wishes not to burn any tokens, it can do so explicitly by reverting in the burn functions.

Similarly to minting, burning applies rules identical to send, but in this instance on the token holder or spender. I.e. equivalently to a regular send, an operator must be authorised to burn the tokens, and the `tokensToSend` hook of the token holder must be called, the only difference compared to a send is that the recipient---the `to` parameter---of the hook is set to the \gls{0x} when burning. Note that when burning the actual balance of the \gls{0x} must not be increased. As a side note, this constraint coupled with the constraint that sending to the \gls{0x} is forbidden, implies that it is impossible for the \gls{0x} to ever hold any ERC777 token.

## Data And Operator Data

Another aspect of minting, sending, and burning tokens is the `data` and `operatorData` parameters, which is an undeniable improvement over ERC20 where only the recipient and amounts of tokens can be specified as part of a transfer. This allows new and exciting use cases such as accepting transfers only if a signed message is provided or specify a purpose for a transfer such that a recipient contract can take appropriate actions.

The `data` parameter is intended to be similar to the `data` parameter of a regular Ethereum transaction, and the standard intentionally does not enforce a specific format for this data only that the recipient defines what data it expects. We expect people will propose new standards related to the format of the `data` parameter which defines the format required for a specific use case. ERC1111\citep{erc1111} is an effort in this direction.

The `operatorData` is the second free bytes parameter associated with a token transaction. It is similar to the `data` parameter, except that is explicitly intended for the operator to provide any information or reason for the transaction. In contrast, the `data` parameter may be provided by either the token holder, the operator, or both.

Ultimately the recipient is free to define which `data` and `operatorData` it expects and reject any transaction which does not matches its expectations. In practice, we expect the recipient to mainly focus on the `data` parameter, with the `operatorData` only providing optional and additional information regarding the transfer.

## View Functions

The view functions in ERC777 have been taken from ERC20. Since those functions do not modify the state, they can be used interchangeably for both standards without creating conflicts. The only constraint is that the information returned by these functions must represent the same entity.

Specifically the `name`, `symbol`, `totalSupply` and `balanceOf` functions are kept. The differences with ERC20 is that the cosmetic or metadata `name` and `symbol` function are now mandatory since they are used by virtually every token today. Mandatory metadata makes the standard easier to understand and simplify the logic when interacting with the token, as we can rely on these function to obtain information like the name to display in the \gls{ui}. Besides, there are more strict constraints on the value returned by calls to the `totalSupply` and `balanceOf` functions. For example, the value returned by the total supply must be equal to the difference between the sum of all the `Minted` events and the sum of all the `Burned` events.

## Decimals And Granularity

The ERC20 `decimal` function is conspicuously absent from the view functions listed above. As previously explained, a variable `decimals` value is problematic. For this reason, the `decimals` has been set at a fixed value of $18$. This renders the `decimals` function pointless. The standard only enforces the implementation of the `decimals` function when implementing an ERC20 backwards-compatible token. In this case, the `decimals` function must both be implemented and return $18$. The choice has been made to make the `decimal` function mandatory in this case, even though ERC20 considers the function optional. The rationale behind this decision comes from the lack of an explicit value defined in the ERC20 standard when the `decimals` function is not defined. Furthermore, requiring people to check whether a token is both ERC20 and ERC777 compatible---and then deduct from the ERC777 standard that the number of decimals is $18$---is both unreliable and terrible \gls{ux}. Besides, this would add an opaque constraint when implementing both standards.

The `decimals` function nonetheless showcases the need to control the partition of a token. In ERC777, a different approach is taken---based on community feedback. As explained, the number of decimals is set to $18$, but the token contract can define a `granularity`. The granularity is the smallest part of the token that's not divisible. Besides, the granularity must be set at creation time and is immutable throughout the lifetime of the token contract. Every mint, burn, and send must be a multiple of the granularity. The recommended granularity is $1$---meaning the token is fully partitionable up to eighteen decimals---unless the token has a good reason not to be fully partitionable. There are such cases, where for example a token represents a gram of precious metal in some vault. If depositing and redeeming metal for tokens is precise to the gram, then it should not be possible to send fractions of a token and the granularity must be set to $10^{18}$. Other examples include tokens pegged on fiat currencies such as the US dollar or the Swiss franc. The smallest denominations are, for the dollar 1 cent or 0.01 dollar and for the Swiss franc 5 cents or 0.05 francs---despite the fractional monetary unit being 0.01 franc---therefore the granularity should be $10^{16}$ and $5\cdot10^{16}$ respectively. The example of the Swiss franc showcases as well the greater flexibility of specifying a granularity instead of a decimals which does not allow to set a value such as $0.05$ as the smallest denomination but only $0.01$ or $0.1$.

## Compatibility

One key aspect for the ERC777 standard is to maintain backward compatibility with the older ERC20 standard. Decentralised blockchains, in general, are notoriously hard and slow to update. A well-known example is \gls{segwit} in Bitcoin, where the regular signalling failed and a new signalling mechanism known as \gls{uasf} was created to force nodes to update to \gls{segwit}. It then took months before activating the related-code for BIP148 and enable nodes to update to \gls{segwit} \citep{uasfco, bip144, bip148}. The same applies to Ethereum ecosystem which translates to many wallets, \glspl{dex} and other \glspl{dapp} that today support ERC20 but will not support ERC777 for years to come if not ever. Hence ERC777 tokens will not be supported on existing platforms immediately, creating a problem for people wishing to sell and trade their ERC777 token. Having a token able to behave at first like an ERC20 token on those platforms alongside with the newer ERC777 behaviour is a major social and economic advantage.

The ERC777 standard also allows some forward-compatibility. Namely, the format of the `data` and `operatorData` have been left free for future standard to define specific formats they need. The ERC820 registry (see section \ref{erc820-pseudo-introspection-registry-contract}) can also be used by a token contract to declare interfaces of future standards which it implements.

### ERC20 Backward Compatibility

Many proposals try to fix ERC20 and amend the specifications to modify the behaviour of functions such as `transfer`. A new standard, on the other hand, should not modify the behaviour of existing functions defined in another standard, but instead, define different functions which implement the new behaviours.

Additionally, having functions with disparate names allows people to differentiate with which standard they are interacting. As an example, with ERC20, to send tokens to a contract, a user should typically use `approve`---instead of calling `transfer` directly---and let the recipient call `transferFrom`. On the other hand, ERC777 defines a `send` function (described later) which is safe to use to send tokens to a contract. Let us assume this `send` function was named `transfer` instead. The user must know figure out beforehand if the tokens he wishes to send implement ERC20 or ERC777. This burden also applies to token forwarding contracts. A contract capable of forwarding tokens typically checks to see if the actual recipient is a regular account or a contract and based on the type of recipient the forwarding contract calls the `transfer` function to forward the tokens or the `approve` function and let the recipient call `transferFrom`. Now to support the "`transfer`" function of ERC777, a forwarding contract would have first to figure out if the token is following ERC777, ERC20 or both. For an ERC777 token, the forwarding contract should call `transfer` For an ERC20 token the forwarding contract should call `approve`. Finally, for an ERC777 and ERC20 token, it depends which standard the `transfer` function follows. Let's assume the `transfer` function follows ERC20 but the forwarding contract believes it follows ERC777, it will call `transfer` and lock the tokens. Overall having the same name would create confusion and result in many mistakes where people end up losing their tokens. We have already witnessed users accidentally sending tokens to the token contract instead of the recipient and locking their tokens forever\footnote{\href{https://www.reddit.com/r/0xProject/comments/7lpc5n/ive_sent_my_tokens_to_the_zrx_smart_contract/}{Reddit/r/0xProject: I’ve sent my tokens to the ZRX smart contract address.. pls help me}} where there was no ambiguity as to which function to use and what the parameters must be.


Fundamentally, ERC777 allows for a token to be implemented as both an ERC20 token and an ERC777 token. This hybrid token possesses two distinct behaviours---one per standard---and the choice of which behaviour is considered is left to anyone who interacts with the token. On the one hand, if a user issues an ERC20 `transfer` call, then for him the token behaves as an ERC20 token. When the user issues an ERC777 `send`, the token behaves as an ERC777 token for him. On the other hand, if the recipient expects to receive ERC777 tokens, he will see a reception as an ERC777 reception, regardless of which function the operator used to send the tokens. Likewise, if the recipient expects an ERC20 token, he can see the reception of tokens as an ERC20 transfer. Even for third-parties who observe a token contract, they can choose to observe the token as an ERC20 token and listen to `Transfer` events or as an ERC777 token and listen to `Minted`, `Sent`, and `Burned` events.

This behaviour is achieved by enforcing that for any transfer of tokens (using either ERC20 or ERC777), both a `Sent` event and a `Transfer` event must be emitted. Correspondingly for minting and burning, alongside the ERC777 `Minted` and `Burned` events, an ERC20 `Transfer` event with `from` and the `to` field set to the \gls{0x} respectively. This is effectively a stricter constraint than ERC20 which only recommends---but does not require---a `Transfer` event with the `from` field set to the \gls{0x} and does not specify the concept of burning. The reason for this stricter constraint is to maintain consistency across the standards and to provide the same data regardless of which standard is used.

It should be noted that defining ERC20-related constraints in ERC777 does not conflict with ERC20. Adding the constraints to ERC20 directly is problematic as it would make existing tokens non-compliant, although it is not an issue if the constraint is expressed in ERC777 and they only apply to ERC20--ERC777 hybrid tokens and none of them exist to this date. ERC20 was intentionally defined more loosely to ensure that it would make some existing tokens retroactively compliant. With the new process for \glspl{eip}, we have the opportunity with ERC777 to clearly state that the standard is still in a draft phase and should not be used. This, of course, does not prevent people from trying to implement the standard, however breaking changes may still happen at this stage, and it is up to the token designer to make sure their implementation is compliant with the final version of ERC777 once it is finalised. Hence we do not have to worry about having to weaken the standard to support some existing and poorly-implemented token. Efforts will need to be put into ensuring the first developers correctly implement the standard, and we have already personally and privately contacted the chief technical officers or founders of some startups to inform them that their current implementation is not compliant with the latest version of ERC777.

## Community And Public Reception

An important factor towards the finalisation and the success of this standard is how well the community receives it. It was crucial to remain open and listen to the views, suggestions and feedback from the community. Most of the feedback has been provided publicly via comments on the ER777 issue \citep{erc777issue}. Some feedback was also given privately via email, instant messages or in person--mostly when meeting other developers at conferences and events.

When reading any comments, instead of going away with a fixed mindset and standardising our own view, we adapted the standard to accommodate for the feedback of the community. Naturally, such effort requires some filtering as not every comment can result in a change of the standard. Some of the messages were inaccurate or wrong due to a misunderstanding of the standard or lack of knowledge regarding the Ethereum ecosystem. In such situations, it was essential for us not to ignore those comments but to reply and try to explain or clarify the topics which were misinterpreted. Doing so gave us the opportunity to understand where the inaccuracies came from and clarify the standard to provide an explicit and clear message for all future readers. Some of the readers or developers who will use the standard may not be native or even proficient English speakers, and it is paramount to make the text plain enough to be understood by all and accessible to anyone.

Some of the comments have provided valuable information which resulted in changes to the standard. An example includes how `decimals` and `granularity` is handled. Initially, the `decimals` function was part of ERC777 and similar to ERC20. Today the function has been removed from the standard, the number of decimals is fixed to $18$, and the concept of granularity and the `granularity` has been defined.

Another example is the `tokensToSend` hook. In the beginning, the standard had a single hook named `tokenFallback`. This hook was later renamed to `tokensReceived`, and the new `tokensToSend` hook was added based on a suggestion of a community member and a general agreement from multiple people that this hook was useful. The addition of the `tokensToSend` hook was not a straightforward decision as some people---including me---initially disagreed with the `tokensToSend` hook. The issue number 23 of the ERC777 reference implementation \citep{erc777impl23} contains a detailed explanation of the drawbacks of the `tokensToSend` hook \citep{erc777impl23comment}. No solution is perfect or optimal, and this hook does have some drawbacks. Notably, it adds some complexity to the logic of the token contract and the movement of tokens. The gas cost of a send becomes more variable as the absence or existence of the hook and the various implementations add more entropy to the actual code execution performed when sending tokens. Another aspect is some of the checks potentially implemented in a `tokensToSend` hook may be implemented via an operator instead.

Ultimately, the complexity increase is less than the advantages brought by the hook, the gas cost can already be quite variable based on `tokensReceived` hooks and while some functionalities can be implemented either in an operator or a `tokensToSend` hook, there is a significant difference: the functionality located within the operator only applies to this specific operator and can be bypassed by using another operator. It also requires the said operator to be a contract. Deploying a `tokensToSend` hook for the functionality allows the logic to be applied to all debits of tokens regardless of which operator it originates.

Unfortunately, some of the comments---originating from what is commonly referred to as a \gls{troll}---are clearly negative and do not bring any constructive criticism. Those comments can be frustrating and diverge the discussion from the actual work into the emotional realm. Thankfully there was never any extreme case so far with respect to the development of the standard. The conventional internet wisdom: "Don't feed the trolls" worked in our case and the members of the community were all wise enough to not take the bait. The best solution was to approach the topic with humour and redirect it away from the \gls{eip} discussion. The only hindrance from these situations was the time loss handling them.

\begin{figure}[!htbp]
  \centering
  \begin{subfigure}[b]{0.8\textwidth}
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0pt}
    \fbox{\includegraphics[width=\textwidth]{erc777troll}}
    \caption{Anonymized and now deleted negative and inaccurate comment on the ERC777 issue.}
    \label{fig:erc777trollcomment}
  \end{subfigure}
  \begin{subfigure}[b]{0.4\textwidth}
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0pt}
    \fbox{\includegraphics[width=\textwidth]{erc777trollanswer}}
    \caption{The witty reply on Twitter.}
    \label{fig:erc777trollanswer}
  \end{subfigure}
  \caption[Negative comments on ERC777]{A negative comment on the ERC777 issue and the witty reply on Twitter to move the discussion away.}
  \label{fig:erc777troll}
\end{figure}

### Logo

The logo was created within the scope of this thesis as part of the community effort to promote the standard. Many ERC20 tokens use the "powered with Ethereum" logo or create custom logos or both. Providing an ERC777 logo will help market both the standard and the specific tokens implementing the standard. The final version of the logo was realised by Samantha Rosso and is available in the \glspl{eip} repository as part of the ERC777 standard\footnote{Folder of the ERC777 logo: \url{https://github.com/ethereum/EIPs/tree/master/assets/eip-777/logo}}.

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.4\textwidth]{erc777-logo-doodle}
\caption[Doodles of the ERC777 logo]{Doodles of the ERC777 logo, with the doodle of the final logo at the bottom left.}
\label{fig:logodoodle}
\end{figure}

The logo is designed to be simple such that it can easily scale both down to small sizes---to be integrated within text---and up to be displayed on web pages and apps. The logo was conceived by Jordi Baylina and Jacques Dafflon. We initially started with three overlapping sevens and quickly converged on the current logo with the double horizontal strikethrough which can be considered as the top bars of two sevens and is associated with currency symbols. The figure \ref{fig:logodoodle} shows the original doodling which led to the final logo. We can see on the doodle multiple attempts to create a logo composed of three sevens. We can see the doodle of the actual logo at the bottom left which is a modified version of the logo at the top left where the slanted bar of three sevens are overlapped. The final logo took this designed and extended two of the top bars to the right to create the double strikethrough common to many currency symbols.

\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{0.19\textwidth}
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0pt}
    \fbox{\includegraphics[width=\textwidth]{ERC-777-logo-beige-192px}}
    \caption{\centering beige variant (\texttt{\#C99D66})}
  \end{subfigure}
  \begin{subfigure}[b]{0.19\textwidth}
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0pt}
    \fbox{\colorbox{gray}{\includegraphics[width=\textwidth]{ERC-777-logo-white-192px}}}
    \caption{\centering white variant (\texttt{\#FFFFFF})}
  \end{subfigure}
  \begin{subfigure}[b]{0.19\textwidth}
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0pt}
    \fbox{\colorbox{gray}{\includegraphics[width=\textwidth]{ERC-777-logo-light_grey-192px}}}
    \caption{\centering light grey variant (\texttt{\#EBEFF0})}
  \end{subfigure}
  \begin{subfigure}[b]{0.19\textwidth}
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0pt}
    \fbox{\includegraphics[width=\textwidth]{ERC-777-logo-dark_grey-192px}}
    \caption{\centering dark grey variant (\texttt{\#3C3C3D})}
  \end{subfigure}
  \begin{subfigure}[b]{0.19\textwidth}
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0pt}
    \fbox{\includegraphics[width=\textwidth]{ERC-777-logo-black-192px}}
    \caption{\centering black variant (\texttt{\#000000})}
  \end{subfigure}
  \caption[ERC777 Logo in all colour variants]{The logo in all its colour variations, inspired by the colours from the Ethereum Visual Identity 1.0.0 guidelines \citep{ethvizguidelines}.}
  \label{fig:erc777logo}
\end{figure}

Ultimately the ERC777 logo is a blank slate which can be derived as a logo for actual tokens, used to promote any technology related to ERC777 or applied as an illustration for articles and posts related to ERC777. The first uses can already be witnessed \citep{cryptofox}, the figure \ref{fig:erc777logouse} is an example of a tweaked version of the logo used in a Russian article.

\begin{figure}[h]
  \centering
  \includegraphics[width=.6\textwidth]{erc777-logo-example}
  \caption{Modified version of the logo used in an article about ERC777 in Russian \citep{cryptofox}.}
  \label{fig:erc777logouse}
\end{figure}

## Reference Implementation

In addition to the ERC777 specifications which are defined in the standard, this \gls{eip} must provide a reference implementation to prove the viability and sanity of the specification. Moreover, in order to take correct decisions when adapting the standard having an implementation to analyse and test our assumptions is paramount.

The ERC777 reference implementation developed within the scope of this thesis in and alongside the standard is open source and available at \url{https://github.com/jacquesd/ERC777}\citep{erc777impl}. A significant effort was made to provide an implementation which is not only readable and easily understandable but reusable as well. Ethereum is somewhat new which implies all developers are new as well. We have personally observed a tendency for developers to copy paste existing contracts and tweaking what they need without fully understand the code they then deploy to the blockchain.

> A blockchain veteran is defined as someone who has worked in the space for more than 9 months. Not to be confused with a blockchain expert, who has worked in the field for 9 weeks. I’ve worked full-time in the space for three years, so I’m slowly learning that I know almost nothing about this technology. \flushright (Cayle Sharrock)

A blatant example of this behaviour is ERC20's `batchTransfer` security flaw \citep{erc20batchtransfer}. Essentially one developer added a new non-standard function to an ERC20 token to transfer tokens to multiple recipients at once. This function did not correctly check for an overflow, and essentially by crafting specific values, a user could use the function to increment its balance by more than the amount sent, effectively minting new tokens for itself.

While the flaw in itself is idiotic and could have easily been avoided, the worst part is that not a single but over a dozen contracts have been found with this vulnerability as those contracts have been found to be essentially copy paste of the original one. Some people upon finding out about the flaw started to speak up about a vulnerability in the ERC20 standard without fully understanding that the vulnerability lied outside of the standard. This is an excellent real-life example which shows how many people lack the skills and understanding.

With the ERC777 reference implementation, we want to do more than just provide some code which people copy paste and tweak. This has many issues, including improperly copy-pasting the code, considering an old (and potentially vulnerable version); copying from already copied and modified versions from other sources. We expect similar situations to happen with ERC777 as we have already witnessed absurd claims related to ERC777 including ERC777 will replace web cookies \citep{cookies} and surprising statements such as operators are similar to artificial intelligence on the blockchain:

> Through the implementation of a program called an "operator" which works like a basic AI system that considers conditions and manages some decision-making for an account, a token holder will have the option of using a robot-like function. The operator can manage an account executing transactions and payments according to the needs of the user and takes care of all transactions for him/her while keeping maximum level of security. \flushright \citep{callwhitepaper}

Those statements illustrate the effort needed to not only clearly explain all aspects of the standard but provide easily understandable and reusable code as well.

Since Solidity supports inheritance, we decided to structure the reference implementation in separate contracts, including a base implementation of ERC777 which anyone can use. On top, we provide a second base implementation which adds support for ERC20 backwards-compatibility. This lets developers easily choose from an ERC20 backwards-compatible version or not. Finally, at the very top, we provide a reference implementation and inherit all of the base code needed to create the token. All we have to provide for the reference implementation is the custom behaviour it needs such as the minting process or overriding the default burn functions to limit the access to burn tokens. The figure \ref{fig:erc777uml} shows a \gls{uml} class diagram of the structure of the various contracts in the ERC777 reference implementation, as well as the connection with the ERC820 Registry and a sample `ExternalERC777Implementation` which uses the base ERC20-compatible token from the ERC777 reference implementation. Note that in this instance, the classes are smart contracts. Moreover, the functions with the wave underline represent `view` functions which do not modify the state of the contract.

\input{fig/erc777_uml}
