# ERC777, A New Advanced Token Standard For Ethereum Tokens

ERC777 is advertised as a a new advanced token standard for Ethereum tokens. It is the result of the work described in this paper and made in collaboration with Jordi Baylina from the White Hat Group and Giveth.

The standard describes three central mechanisms: sending tokens, minting tokens and receiving tokens. Those mechanisms are performed by a specific role---an operator---which is also defined in the standard. They also take advantage of hooks---specific functions which are called to notify the debit or credit of tokens. Lastly, ERC777 includes extra constraints for backwards compatibility with ERC20.

Creating a new standard requires careful considerations. Many aspects had to be considered such as security, usability, compatibility with the existing ecosystem and backward compatibility with existing ERC20 infrastructures. All things considered, ERC777 brings many enhancements including data associated with transactions, operators, hooks and backward-compatibility with ERC20 which address the previously mentioned considerations.

## Operators

An operator is a specific role which must be defined first, in order to properly understand the three mechanisms described below. In one sentence:

> An operator is an address which is allowed to send and burn tokens on behalf of another address \citep{erc777}.

On top, of this core definition, constraints are defined and applied for all operators. First, every address is always an operator for itself. This right is not revocable. Second, any address--regular accounts or contract---is allowed to authorize and later revoke other addresses as their operators. Therefore some accounts may have their token funds managed by another party. Ideally, operators are intended to be contracts whose code may be audited. As a result, users can authorize a contract as their operator without the fear of the operator withdrawing all their tokens. Evidently this implies users have previously verified the code of the operator and they have convinced themselves the code operator does not include vulnerabilities and is not able to withdraw all the funds. Examples of such operator contracts include payment or cheque processors, \glspl{dex}, subscription managers and automatic payment systems.

There are also interesting scenarios which leverage hooks to authorize regular accounts as operators whilst only letting them spend tokens according to specific rules.

### Default Operators

Any address must explicitly authorize operators---unless it is the address itself. Additionally, any token may define a set of operators at creation time which are implicitly authorized for all token holders. This feature allows token designers to offer additional features specific to their token---with a modular design---to let their users move their funds more seamlessly. Taking inspiration from the previous examples for operators. If a token is used a form of payment for subscription. The company behind the service may be interested to not only create the token but an operator to directly and regularly levy the subscription fee. Since the use---and therefore the value---of the token are based on this subscription service, it is logical to authorize the subscription operator by default. Obviously, default operators can be revoked by the token holder and a token contract must not be able to change the list of default operators after the contract is created.

### Authorizing Operators

Authorizing operators is the process where a token holder authorize some address as its operator. A token holder may authorize many operators at the same time. However only the token holder can authorize operators for itself. This is an important constraint for contracts which must correctly implement some logic to authorize the operators it needs. A simple example is to have an authorize call in the constructor of the function.

ERC777 defines a specific function to authorize an operator: `authorizeOperator`. This function takes the address of the operator as parameter and authorizes it for the address which initialized the call (`msg.sender`). The standard requires the implementation of this function but it does not however constrain the authorization mechanism to this function. In other words, the token may define other mechanisms to authorize operators as long as those mechanisms are compliant. For example they must emit the `AuthorizedOperator` event with the correct data.

## Hooks

## Sending Tokens

## Minting Tokens

## Burning Token

## View Functions

The view functions in ERC777 have been taken from ERC20. Since those functions do not modify the state, they can be used interchangeably for both standards without creating conflicts. The only constraint is that the information returned by these functions must represent the same entity.

Specifically the `name`, `symbol`, `totalSupply` and `balanceOf` functions are kept. The differences with ERC20 is that the cosmetic `name` and `symbol` function are now mandatory. In addition there are more strict constraints on the value returned by calls to the `totalSupply` and `balanceOf` functions.

## Decimals

The ERC20 `decimal` function is notoriously absent from the view functions listed above. As previously explained, a variable `decimals` value is problematic. For this reason the `decimals` has been set at a fixed value of $18$. This renders the `decimals` function pointless. The standard only enforces the implementation of the `decimals` function when implementing a ERC20 backward-compatible token. In this case the `decimals` function must both be implemented and return $18$. The choice has been made to make the `decimal` function mandatory in this case, even though ERC20 considers the function optional. The rational behind this decision comes from the lack of an explicit value defined in the ERC20 standard when the `decimals` function is not defined. Furthermore, requiring people to check wether a token is both ERC20 and ERC777 compatible---and then deduct from the ERC777 standard that the number of decimals is $18$---is both unreliable and terrible user experience. Besides, this would add an opaque constraint when implementing both standards.

## Compatibility

One key aspect for the ERC777 standard is to maintain compatibility with the older ERC20 standard. The Ethereum ecosystem is hard and slow to update. This translates to many wallets, \glspl{dex} and other dapps which today support ERC20 but will not support ERC777 for years to come if not ever. Hence ERC777 tokens will not be supported on existing platforms immediately, which is a problem for people wishing to sell and trade their ERC777 token. Having a token able to behave at first like an ERC20 token on those platforms alongside with the newer ERC777 behavior is a major social and economic advantage.

### Notifying The Recipient

One of the main feature of ERC777 is to do away with the `approve` and `transferFrom` mechanism and instead provide a single mechanism to send tokens to both regular accounts and contracts. For a contract, it is then mandatory for it to be notified on-chain when it receives tokens. This is done with the use of "hooks" or specific functions which are called

### ERC20 Backward Compatibility

Many proposition try to fix ERC20 and amend the specifications to modify the behavior of functions such as `transfer`. A new standard on the other hand should not modify the behavior of existing functions defined in another standard, but rather define different functions which implement the new behaviors.

Additionally, having functions with disparate names allows people to differentiate with which standard they are interacting with. As an example, with ERC20, to send tokens to a contract, a user should typically use `approve`---instead of calling `transfer` directly---and let the recipient call `transferFrom`. On the other hand, ERC777 defines a `send` function (described later) which is safe to use to send tokens to a contract. Let us assume this `send` function was named `transfer` instead. The user must know figure out beforehand if the tokens he wishes to send implement ERC20 or ERC777. This burden also applies to contract forwarding contracts. Overall having the same name would create confusion and result in many mistakes where people end up loosing their tokens.




Explain ERC777 in thorough details:

 - specifications
 - ERC820
 - `TokensSender` and `TokensRecipient`
 - Operators
 - ERC20 compatibility
 - Collaboration with Jordi Baylina
 - Public Reception
